操作系统设计与分析复习

第1章

1、	操作系统的两大主要作用是什么
为应用程序提供如何使用硬件资源的抽象，管理硬件资源
通过资源管理，提高系统的使用效率；改善人机界面，向用户提供友好的工作环境。

2、	分时系统和多道程序系统的区别是什么
多道程序系统是在计算机内存中同时存放几道相互独立的程序，使它们在管理程序控制之下，相互穿插的运行。 两个或两个以上程序在计算机系统中同处于开始和结束之间的状态。这就称为多道程序技术运行的特征：多道、宏观上并行、微观上串行。
分时操作系统是使一台计算机同时为几个、几十个甚至几百个用户服务的一种操作系统。把计算机与许多终端用户连接起来，分时操作系统将系统处理机时间与内存空间按一定的时间间隔，轮流地切换给各终端用户的程序使用。由于时间间隔很短，每个用户的感觉就像他独占计算机一样。分时操作系统的特点是可有效增加资源的使用率。例如UNIX系统就采用剥夺式动态优先的CPU调度，有力地支持分时操作。
分时操作系统是给不同用户提供程序的使用，而多道程序系统则是不同程序间的穿插运行。
总之，分时操作系统主要是针对于多用户来说的，而多道程序系统主要是针对于多程序来说的，注意用户和程序之间的区别。

10、 内核态和用户态有哪些区别？解释在设计操作系统时存在两种不同的模式有什么帮助
虽然用户态下和内核态下工作的程序有很多差别，但最重要的差别就在于特权级的不同，即权力的不同。运行在用户态下的程序不能直接访问操作系统内核数据结构和程序，比如上面例子中的testfork()就不能直接调用 sys_fork()，因为前者是工作在用户态，属于用户态程序，而sys_fork()是工作在内核态，属于内核态程序。
由于需要限制不同的程序之间的访问能力, 防止他们获取别的程序的内存数据, 或者获取外围设备的数据, 并发送到网络, CPU划分出两个权限等级 -- 用户态和内核态。
在CPU的所有指令中，有一些指令是非常危险的，如果错用，将导致整个系统崩溃。
linux的内核是一个有机的整体。每一个用户进程运行时都好像有一份内核的拷贝，每当用户进程使用系统调用时，都自动地将运行模式从用户级转为内核级，此时进程在内核的地址空间中运行。

11、 
盘片 片面 和 磁头
硬盘中一般会有多个盘片组成，每个盘片包含两个面，每个盘面都对应地有一个读/写磁头。受到硬盘整体体积和生产成本的限制，盘片数量都受到限制，一般都在5片以内。盘片的编号自下向上从0开始，如最下边的盘片有0面和1面，再上一个盘片就编号为2面和3面。
如下图：
 
 
 
图1
扇区 和 磁道
下图显示的是一个盘面，盘面中一圈圈灰色同心圆为一条条磁道，从圆心向外画直线，可以将磁道划分为若干个弧段，每个磁道上一个弧段被称之为一个扇区（图践绿色部分）。扇区是磁盘的最小组成单元，通常是512字节。（由于不断提高磁盘的大小，部分厂商设定每个扇区的大小是4096字节）
 
 
图2
磁头 和 柱面
硬盘通常由重叠的一组盘片构成，每个盘面都被划分为数目相等的磁道，并从外缘的“0”开始编号，具有相同编号的磁道形成一个圆柱，称之为磁盘的柱面。磁盘的柱面数与一个盘面上的磁道数是相等的。由于每个盘面都有自己的磁头，因此，盘面数等于总的磁头数。 如下图
 
 
 
图3
磁盘容量计算
存储容量 ＝ 磁头数 × 磁道(柱面)数 × 每道扇区数 × 每扇区字节数
图3中磁盘是一个 3个圆盘6个磁头，7个柱面（每个盘片7个磁道） 的磁盘，图3中每条磁道有12个扇区，所以此磁盘的容量为：
存储容量 6 * 7 * 12 * 512 = 258048
每个磁道的扇区数一样是说的老的硬盘，外圈的密度小，内圈的密度大，每圈可存储的数据量是一样的。新的硬盘数据的密度都一致，这样磁道的周长越长，扇区就越多，存储的数据量就越大。
磁盘读取响应时间
1.	寻道时间：磁头从开始移动到数据所在磁道所需要的时间，寻道时间越短，I/O操作越快，目前磁盘的平均寻道时间一般在3－15ms，一般都在10ms左右。
2.	旋转延迟：盘片旋转将请求数据所在扇区移至读写磁头下方所需要的时间，旋转延迟取决于磁盘转速。普通硬盘一般都是7200rpm，慢的5400rpm。
3.	数据传输时间：完成传输所请求的数据所需要的时间。
小结一下：从上面的指标来看、其实最重要的、或者说、我们最关心的应该只有两个：寻道时间；旋转延迟。
读写一次磁盘信息所需的时间可分解为：寻道时间、延迟时间、传输时间。为提高磁盘传输效率，软件应着重考虑减少寻道时间和延迟时间。

12、 

17、什么是陷阱指令？在操作系统中解释它的用途
所有用户程序都是运行在用户态的, 但是有时候程序确实需要做一些内核态的事情, 例如从硬盘读取数据, 或者从键盘获取输入等. 而唯一可以做这些事情的就是操作系统, 所以此时程序就需要先操作系统请求以程序的名义来执行这些操作
这时需要一个这样的机制: 用户态程序切换到内核态, 但是不能控制在内核态中执行的指令
这种机制叫系统调用, 在CPU中的实现称之为陷阱指令(Trap Instruction)

 

23、 
1，5，9，2

27、现代操作系统将进程的地址空间从机器物理内存中分离出来，列举这种设计的两个好处
 
进程地址空间不隔离。由于程序都是直接访问物理内存，所以恶意程序可以随意修改别的进程的内存数据，以达到破坏的目的。有些非恶意的，但是有 bug 的程序也可能不小心修改了其它程序的内存数据，就会导致其它程序的运行出现异常。这种情况对用户来说是无法容忍的，因为用户希望使用计算机的时候，其中一个任务失败了，至少不能影响其它的任务。
内存使用效率低。在 A 和 B 都运行的情况下，如果用户又运行了程序 C ，而程序 C 需要 20M 大小的内存才能运行，而此时系统只剩下 8M 的空间可供使用，所以此时系统必须在已运行的程序中选择一个将该程序的数据暂时拷贝到硬盘上，释放出部分空间来供程序 C 使用，然后再将程序 C 的数据全部装入内存中运行。可以想象得到，在这个过程中，有大量的数据在装入装出，导致效率十分低下。

 
第2章
https://webcache.googleusercontent.com/search?q=cache:V8UGnMM9Tv0J:https://lhyd.top/%3Fp%3D336035+&cd=5&hl=zh-CN&ct=clnk

3、当代计算机中，为什么中断处理程序至少有一部分是由汇编语言编写的？
通常，高级语言不允许访问CPU 硬件，而这种访问是必需的。例如，中断处理程序可能需要禁用和启用某个特定设备的中断服务，或者处理进程堆栈区的数据。另外，中断服务例程需要尽快地执行。

4、中断或系统调用把控制权转交给操作系统时，为什么通常会用到与被中断进程的栈分离的内核栈？
内核使用单独的堆栈有若干的原因。其中两个原因如下：
•	首先，不希望操作系统崩溃，由于某些用户程序不允许足够的堆栈空间。
•	第二，如果内核将数据保留在用户空间，然后从系统调用返回，那么恶意的用户可能使用这些数据找出某些关于其它进程的信息。


5、 
5、一个计算机系统的内存有足够的空间容纳5个程序。这些程序又一半时间处于等待I/O的空闲状态。请问CPU时间浪费的比例是多少？
五个进程都空闲的概率是1/32，所以CPU空闲时间是1/32。
6、一个计算机的RAM有4GB，其中操作系统占512M。所有进程都占256M并且特征相同。要是CPU利用率达到99%, 最大I/O等待是多少？
内存中有足够的空间容纳14个进程。如果一个进程的I/O是P，那么它们都在等待I/O的概率是P 14。通过将其等于0.01，我们得到方程p 14=0。01。解决这个问题，我们得到p=0。72，因此我们可以容忍高达72%I/O等待的进程
7、多个作业能够并行运行，比它们顺序执行完成的要快。假设有两个作业同时开始执行，每个需要10分钟的CPU时间。如果顺序执行，那么最后一个作业需要多长时间可以完成？如果并行执行又需要多长时间？假设I/O等待占50%。
CPU利用率计算公式：CPU利用率 = 1 – p^n 。设运行作业所需要的时间为T。
如果每个工作都有50%的I/O等待，那么在没有竞争的情况下，完成该工作需要40分钟。如果按顺序运行，第二个将在第一个启动后80分钟完成。对于两个作业，CPU利用率大约为1-0.5^2。因此，每一个系统每分钟可获得0.375 cpu分钟的实时数据。要累积20分钟的CPU时间，作业必须运行20/0.375分钟，或大约53.33分钟。因此，按顺序运行的作业在80分钟后完成，但并行运行的作业在53.33分钟后完成。
8、考虑一个6级多道程序系统（内存可同时容纳6个程序）。假设每个进程I/O等待时间40%，那么CPU利用率是多少？
所有进程等待I/O的概率为0.4^6，即0.004096。因此，CPU利用率=1−0。004096=0:995904。

45、 
45、有5个批处理作业A到E，它们几乎同时到达一个计算中心。估计它们的运行时间分別为10，6，2，4和8分钟。其优先级（由外部设定）分别为3，5，2，1和4，其中5为最高优先级。对于下列每种调度算法，计算其平均进程周转时间，可忽略进程切换的开销。
a) 轮转法。
b) 优先级调度。
c) 先来先服务（按照10，6，2，4，8次序运行)。
d) 最短作业优先。
对a)，假设系统具有多道程序处理能力，每个作业均公平共享CPU时间，对b)到d) ，假设任一时刻只有一个作业运行，直到结束。所有的作业都完全是CPU密集型作业。
答：对于时间片轮转，在头10分钟里，每个作业获得1/5的CPU时间。在第10 分钟时，C结束。在接下来的8分钟里，每个作业获得 1/4 的CPU时间，然后D完成，然后，在接下来的6分钟内，余下的3个作业各获得1/3的CPU时间，直到B结束，以此类推。因此，5个作业的完成时间分别为是10, 18, 24, 28和30, 平均为22分钟。对于优先级调度，5最先运行，6分钟完成。其它作业分别在第14, 24, 26和30分钟完成，平均为20分钟。如果作业按A->E的次序执行，则分别在第10,16, 18, 22和30分钟完成，因此，平均为19.2分钟。最后，最短作业优先调度的完成时间分别为第2, 6, 12, 20和30分钟，平均为14分钟。


 
第3章

4、 
4、第一次安装需要20 MB、10 MB、18 MB。最佳匹配需要12 MB、10 MB和9 MB
。最差的匹配需要20 MB、18 MB和15 MB。下一个匹配需要20 MB，18MB和9MB。

5、物理地址和虚拟地址有什么区别？
CPU是通过地址来访问内存中的存储单元的，而地址分为物理地址和虚拟地址，若MMU单元未开启则CPU直接通过地址总线访问芯片引脚，若MMU开启则将地址信息传递给MMU单元，并通过MMU单元获取实际物理地址并发送到外部地址引脚。
物理地址：用于内存芯片级的单元寻址，与处理器和CPU连接的地址总线相对应。在存储器里是以字节为单位存储信息的，为了保证数据存取的正确性，需要对每个字节单元进行唯一标识，这个唯一标识就是物理地址，又称为实际地址或绝对地址。
虚拟地址：内存管理单元MMU为了统一管理物理内存而对物理没存进行的再分配，与物理内存通过特定的寻址方式一一对应。 MMU通过虚拟地址和页面表位置信息，按照转换逻辑获得对应物理地址，输出到地址总线上。


6、对于4kb的页面大小，（page，offset）对是（4， 3616），（8，0）和（14，2656）。对于8kb的页面大小，它们是（2， 3616）、（4、0）和（7，2656）。

7、 (a) 8212. (b) 4100. © 24684.

36、 
NRU删除第2页。FIFO删除第3页。LRU删除第1页。第二次机会删除第2页。

最近最久未使用(LRU)置换算法
选择最近最长时间未访问过的页面予以淘汰，它认为过去一段时间内未访问过的页面，在最近的将来可能也不会被访问。
该算法为每个页面设置一个访问字段，来记录页面自上次被访问以来所经历的时间，淘汰页面时选择现有页面中值最大的予以淘汰。
再对上面的实例釆用LRU算法进行页面置换，如图3-29所示。
进程第一次对页面2访问时，将最近最久未被访问的页面7置换出去。然后访问页面3时，将最近最久未使用的页面1换出。

时钟(CLOCK)置换算法
产生原因
LRU算法的性能接近于OPT，但是实现起来比较困难，且开销大；FIFO算法实现简单，但性能差。

原理
简单的CLOCK算法是给每一帧关联一个附加位，称为使用位。当某一页首次装入主存时，该帧的使用位设置为1;当该页随后再被访问到时，它的使用位置为0。

对于页替换算法，用于替换的候选帧集合看做一个循环缓冲区，并且有一个指针与之相关联。当某一页被替换时，该指针被设置成指向缓冲区中的下一帧。当需要替换一页时，操作系统扫描缓冲区，以查找使用位被置为0的一帧。每当遇到一个使用位为1的帧时，操作系统就将该位重新置为0；如果在这个过程开始时，缓冲区中所有帧的使用位均为0，则选择遇到的第一个帧替换；如果所有帧的使用位均为1,则指针在缓冲区中完整地循环一周，把所有使用位都置为0，并且停留在最初的位置上，替换该帧中的页。

第二次机会算法的基本思想是与FIFO相同的，但是有所改进，避免把经常使用的页面置换出去。当选择置换页面时，依然和FIFO一样，选择最早置入内存的页面。但是二次机会法还设置了一个访问状态位。所以还要检查页面的的访问位。如果是0，就淘汰这页；如果访问位是1，就给它第二次机会，并选择下一个FIFO页面。当一个页面得到第二次机会时，它的访问位就清为0，它的到达时间就置为当前时间。如果该页在此期间被访问过，则访问位置为1。这样给了第二次机会的页面将不被淘汰，直至所有其他页面被淘汰过（或者也给了第二次机会）。因此，如果一个页面经常使用，它的访问位总保持为1，它就从来不会被淘汰出去。
第二次机会算法可视为一个环形队列。用一个指针指示哪一页是下面要淘汰的。当需要一个存储块时，指针就前进，直至找到访问位是0的页。随着指针的前进，把访问位就清为0。在最坏的情况下，所有的访问位都是1，指针要通过整个队列一周，每个页都给第二次机会。这时就退化成FIFO算法了。


 
第4章

21、说明硬链接和符号链接的优点
硬连接指通过索引节点来进行连接。在Linux的文件系统中，保存在磁盘分区中的文件不管是什么类型都给它分配一个编号，称为索引节点号(Inode Index)。在Linux中，多个文件名指向同一索引节点是存在的。一般这种连接就是硬连接。硬连接的作用是允许一个文件拥有多个有效路径名，这样用户就可以建立硬连接到重要文件，以防止“误删”的功能。其原因如上所述，因为对应该目录的索引节点有一个以上的连接。只删除一个连接并不影响索引节点本身和其它的连接，只有当最后一个连接被删除后，文件的数据块及目录的连接才会被释放。也就是说，文件真正删除的条件是与之相关的所有硬连接文件均被删除。
另外一种连接称之为符号连接（Symbolic Link），也叫软连接。软链接文件有类似于Windows的快捷方式。它实际上是一个特殊的文件。在符号连接中，文件实际上是一个文本文件，其中包含的有另一文件的位置信息。
硬链接 有点限制， 不能跨文件系统，不能对文件夹使用。
软连接 没有上面的限制。
硬链接在删除文件的时候，只有把所有的硬链接删掉，文件才会删除。
软链接则不是，链接的文件删掉，软链接就失效了。



 
第5章

4、请解释超标量体系结构是如何权衡精确中断与非精确中断的？

25、光盘和磁盘和固态硬盘的优点和缺点各是什么？
固态硬盘毋庸置疑拥有超高的 读写速度 和 稳定性 。
在出现固态硬盘之前，所有的电脑都是使用的机械硬盘。它的原理类似于光盘，主要结构是一个高速旋转的盘片 和在盘片上来回读写数据的 磁头。而固态硬盘则是以 电子存储 的方式来存储数据的，主要由主控芯片、闪存芯片、固件算法等组成，和我们平常使用的U盘类似，不过比U盘使用的闪存芯片更多。
1、读写速度快：采用闪存作为存储介质，读取速度相对于机械硬盘更快。固态硬盘不用磁头，寻道时间几乎为0。

持续写入的速度非常惊人，固态硬盘厂商大多说会宣称自家的固态硬盘持续读写速度超过了550MB/s！

固态硬盘的快绝对不仅仅体现在持续读写上，随机读写速度快才是固态硬盘的终极奥义，这最直接体现在绝大部分的日常操作中。

与之相关的还有极低的存取时间，最常见的7200转机械硬盘的寻道时间一般为12-14毫秒，而固态硬盘可以轻易达到0.1毫秒甚至更低。

2、防震抗摔性：传统硬盘都是磁碟型的，数据储存在磁碟扇区里。而固态硬盘使用闪存颗粒（即mp3、U盘等存储介质）制作而成，所以SSD硬盘内部不存在任何机械部件，在发生碰撞和震荡时能够将数据丢失的可能降到最小。

3、低功耗：固态硬盘的功耗上要低于传统硬盘。

4、无噪音： 固态硬盘没有机械马达和风扇，工作时噪音值为0分贝。内部不存在任何机械活动部件，不会发生机械故障，也不怕碰撞、冲击、振动。由于固态硬盘采用无机械部件的闪存芯片，所以具有了发热量小，散热快的特点。

5、工作温度范围大：典型的硬盘驱动器只能在5 ~ 55摄氏度范围内工作。而大多数固态硬盘可在 -10 ~ 70摄氏度工作。固态硬盘的接口规范和定义、功能和使用方法上与普通硬盘相同，在产品外形和尺寸上也与普通硬盘一致。其芯片的工作温度范围很宽（-40 ~ 85摄氏度）。

6、轻便： 固态硬盘在重量方面很轻，与常规1.8英寸硬盘相比，重量轻20 ~ 30克，现在M.2等固态硬盘能够做到和内存大小相当，小巧轻便，日常携带十分方便。
1、从外观比较固态硬盘的体积比机械硬盘小很多，有利于笔记本降低厚度。
2、固态硬盘没有机械硬盘所用的电机，启动速度非常快。因为固态硬盘不需要磁头，读取的速度是机械硬盘的几倍，即便磁盘碎片也不会影响读取速度。
3、固态硬盘没有机械马达和电扇，所以没有任何噪音，机械硬盘可以理解为是一部精密仪器，固态硬盘是一块集成电路，所以抗震性和温度的适应性高于机械硬盘。
4、固态硬盘的成本高，而且容量一直低于机械硬盘很多。受到读写次数的限制，固态硬盘的使用寿命比较短。
5、磁盘碎片不影响固态硬盘读取，但影响磁盘的写入，速度低于机械硬盘。比机械硬盘更容易受到外界干扰，而且数据损坏是难以修复的。


1.	DVD-R或DVD+R刻录后是不可以修改的，非常适合资料等存档，所以很多单位用光盘来做数据存档。
2.	分发或保存数据等成本低，即使零售渠道买光盘也是在1-2元内，批量成本更低。这方便是U盘和硬盘无法可比的。
3.	可靠性高，虽然网盘可以很方便的传输数据，不考虑网络成本，成本也低，哪个网盘可以保障稳定十几年，当然没有这个承诺，而光盘可以。
4.	综上所述，光盘是结合读写分离、成本低，可靠性高特性的最佳方式，在相当长的时间内，光盘还会一直存在，不排除在新的技术和外部环境变化重新流行的可能。



 
第9章

1、
 
机密性是不将有用信息泄漏给非授权用户的特性。可以通过信息加密、身份认证、访问控制、安全通信协议等技术实现，信息加密是防止信息非法泄露的最基本手段，主要强调有用信息只被授权对象使用的特征。
完整性是指信息在传输、交换、存储和处理过程中，保持信息不被破坏或修改、不丢失和信息未经授权不能改变的特性，也是最基本的安全特征。
可用性指信息资源可被授权实体按要求访问、正常使用或在非正常情况下能恢复使用的特性。在系统运行时正确存取所需信息，当系统遭受意外攻击或破坏时，可以迅速恢复并能投入使用。是衡量网络信息系统面向用户的一种安全性能，以保障为用户提供服务。

2、
 
可信计算基（英語：Trusted computing base, TCB）是指为实现计算机系统安全保护的所有安全保护机制的集合，机制可以硬件、固件和软件的形式出现[1]。一旦可信计算机基的某个构件出现程序错误或者安全隐患，就对整个系统的安全造成危害。 与之相反，如果除可信计算基之外的系统的其他部分出现问题，也只是泄漏了系统安全策略赋予它们的相关权限而已，这些权限一般都是比较低的。
精心设计和实现的系统可信计算基对系统整体安全至关重要。现代操作系统努力降低TCB的大小，使得通过手工或电脑辅助软件审计（software audit（英语：软件审计））或形式化验证的方法对其代码库彻底的检查成为可能。



